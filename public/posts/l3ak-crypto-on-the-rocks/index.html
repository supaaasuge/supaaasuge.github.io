<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content=""
  />
  
    
      <title>L3AK CTF - Crypto On The Rocks | Supaaasuge&#39;s Blog</title>
    
  
  <link rel="stylesheet" href="/css/reset.css"/>
  <link rel="stylesheet" href="/css/font.css"/>
  <link rel="stylesheet" href="/css/smigle.css"/>
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
</head>

  <body>
    <div id="root">
      <header>
  <div id="brand">
    <a class="icon-link" href="https://supaaasuge.github.io/">
      <img
        class="icon"
        src="/images/brandIcon.svg"
      />
    </a>
    <div class="text">
      <a href="https://supaaasuge.github.io/"><h1>Supaaasuge&#39;s Blog</h1></a>
      <h3>Aspiring IT/Cybersecurity Professional</h3>
    </div>
  </div>
  <nav>
    
      
        
        <a href="/"><b>Home</b></a>
      
         | 
        <a href="/about/"><b>About</b></a>
      
         | 
        <a href="/posts/"><b>Posts</b></a>
      
         | 
        <a href="/categories/"><b>Categories</b></a>
      
         | 
        <a href="/tags/"><b>Tags</b></a>
      
         | 
        <a href="/index.xml"><b>RSS</b></a>
      
    
  </nav>
  <hr />
</header>

      <div id="content">
        
  <main>
    <article>
      <h1 class="title">L3AK CTF - Crypto On The Rocks</h1>
      
      <div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2024-06-01</time>
    <span>in</span>
    
      <a href="/categories/ctf">CTF</a>
  </strong>
  <span> • 2484 words</span>
  <span> • 12 minute read</span>
  
  
    <div>
      <span>Tags:</span>
      
        <a href="/tags/cryptography">Cryptography</a>, 
        <a href="/tags/ecdsa">ECDSA</a>, 
        <a href="/tags/biased-nonces">Biased Nonces</a>, 
        <a href="/tags/lll">LLL</a>
    </div>
  
</div>

      <div class="content"><h1 id="crypto-on-the-rocks-solution">Crypto on the Rocks Solution</h1>
<p>This challenge was inspired by <a href="https://www.cert.europa.eu/publications/security-advisories/2024-039/pdf">CVE-2024-31497</a>.</p>
<p>Within PuTTY, when utilizing the NIST P-521 elliptic curve, the implementation generates nonces with the first 9 bits set to zero. PuTTY&rsquo;s technique worked by making a SHA-512 hash and then reducing it mod $q$, where $q$ is the order of the group used in the ECDSA system.</p>
<h2 id="introduction">Introduction</h2>
<p>This challenge involves breaking the ECDSA (Elliptic Curve Digital Signature Algorithm) using a lattice-based attack. The vulnerability arises from the biased $k$ values used during the signing process. By exploiting these biases, we can recover the private key and decrypt the encrypted flag. This writeup will provide a detailed explanation of the steps involved in solving the challenge.</p>
<h3 id="challenge-writeup">Challenge Writeup</h3>
<p><strong>Challenge Source Code</strong></p>
<ul>
<li><code>chal.py</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> sage.all <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#f92672">from</span> typing <span style="color:#f92672">import</span> Tuple
<span style="color:#f92672">import</span> hashlib
<span style="color:#f92672">from</span> Crypto.Cipher <span style="color:#f92672">import</span> AES
<span style="color:#f92672">from</span> Crypto.Util.number <span style="color:#f92672">import</span> long_to_bytes
<span style="color:#f92672">from</span> Crypto.Util.Padding <span style="color:#f92672">import</span> pad
<span style="color:#f92672">from</span> Crypto.Random <span style="color:#f92672">import</span> get_random_bytes
<span style="color:#f92672">import</span> re
p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span>
K <span style="color:#f92672">=</span> GF(p)
a <span style="color:#f92672">=</span> K(<span style="color:#ae81ff">0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc</span>)
b <span style="color:#f92672">=</span> K(<span style="color:#ae81ff">0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00</span>)
E <span style="color:#f92672">=</span> EllipticCurve(K, (a, b))
G <span style="color:#f92672">=</span> E(<span style="color:#ae81ff">0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66</span>, <span style="color:#ae81ff">0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650</span>)
E<span style="color:#f92672">.</span>set_order(<span style="color:#ae81ff">0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x1</span>)
n <span style="color:#f92672">=</span> G<span style="color:#f92672">.</span>order()


FLAG: str <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#39;flag.txt&#39;</span>, <span style="color:#e6db74">&#39;r&#39;</span>)<span style="color:#f92672">.</span>read()<span style="color:#f92672">.</span>strip()
KEY: int <span style="color:#f92672">=</span> randint(<span style="color:#ae81ff">1</span>, n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
Q: int <span style="color:#f92672">=</span> KEY<span style="color:#f92672">*</span>G
AES_KEY <span style="color:#f92672">=</span> hashlib<span style="color:#f92672">.</span>sha256(long_to_bytes(KEY))<span style="color:#f92672">.</span>digest()

INVALID_ATTEMPTS <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">banner</span>() <span style="color:#f92672">-&gt;</span> str:
    banner <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">
</span><span style="color:#e6db74">██████████╗░░█████╗░░█████╗░███████╗█
</span><span style="color:#e6db74">[=] ------------ Menu------------ [=]
</span><span style="color:#e6db74">[+] !1: Get Public Key            [+]
</span><span style="color:#e6db74">[+] !2: Sign a message            [+]
</span><span style="color:#e6db74">[+] !3: Verify a signature        [+]
</span><span style="color:#e6db74">[+] !4: Get the encrypted flag    [+]
</span><span style="color:#e6db74">[+] !5: Exit                      [+]
</span><span style="color:#e6db74">[=] ------------------------------[=]
</span><span style="color:#e6db74">██████████╗░░█████╗░░█████╗░███████╗█
</span><span style="color:#e6db74"></span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;&#34;&#34;</span>
    <span style="color:#66d9ef">return</span> banner
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_k</span>() <span style="color:#f92672">-&gt;</span> int:
    <span style="color:#66d9ef">return</span> int<span style="color:#f92672">.</span>from_bytes(hashlib<span style="color:#f92672">.</span>sha512(os<span style="color:#f92672">.</span>urandom(<span style="color:#ae81ff">512</span><span style="color:#f92672">//</span><span style="color:#ae81ff">8</span>))<span style="color:#f92672">.</span>digest(), byteorder<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;big&#39;</span>) <span style="color:#f92672">%</span> n

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">digest</span>(msg) <span style="color:#f92672">-&gt;</span> int:
    <span style="color:#66d9ef">if</span> isinstance(msg, str):
        msg <span style="color:#f92672">=</span> msg<span style="color:#f92672">.</span>encode()
    <span style="color:#66d9ef">return</span> int<span style="color:#f92672">.</span>from_bytes(hashlib<span style="color:#f92672">.</span>sha256(msg)<span style="color:#f92672">.</span>digest(), byteorder<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;big&#39;</span>)


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ecdsa_verify</span>(Q, m, r, s) <span style="color:#f92672">-&gt;</span> bool:
    e <span style="color:#f92672">=</span> digest(m)
    w <span style="color:#f92672">=</span> pow(s, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, n)
    u1 <span style="color:#f92672">=</span> int((e <span style="color:#f92672">*</span> w) <span style="color:#f92672">%</span> n)  
    u2 <span style="color:#f92672">=</span> int((r <span style="color:#f92672">*</span> w) <span style="color:#f92672">%</span> n)  
    P <span style="color:#f92672">=</span> (u1 <span style="color:#f92672">*</span> G) <span style="color:#f92672">+</span> (u2 <span style="color:#f92672">*</span> Q)
    <span style="color:#66d9ef">return</span> r <span style="color:#f92672">==</span> int(P<span style="color:#f92672">.</span>xy()[<span style="color:#ae81ff">0</span>])


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ecdsa_sign</span>(d: int, m: str) <span style="color:#f92672">-&gt;</span> Tuple[int, int]:
    e <span style="color:#f92672">=</span> digest(m)
    k <span style="color:#f92672">=</span> get_k()
    P <span style="color:#f92672">=</span> k <span style="color:#f92672">*</span> G
    r_i <span style="color:#f92672">=</span> int(P<span style="color:#f92672">.</span>xy()[<span style="color:#ae81ff">0</span>])
    s_i <span style="color:#f92672">=</span> (pow(k, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, n) <span style="color:#f92672">*</span> (e<span style="color:#f92672">+</span>r_i<span style="color:#f92672">*</span>d)) <span style="color:#f92672">%</span> n
    <span style="color:#66d9ef">return</span> (r_i, s_i)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">send_flag</span>() <span style="color:#f92672">-&gt;</span> str:
        flag <span style="color:#f92672">=</span> FLAG<span style="color:#f92672">.</span>encode()
        iv <span style="color:#f92672">=</span> get_random_bytes(<span style="color:#ae81ff">16</span>)
        cipher <span style="color:#f92672">=</span> AES<span style="color:#f92672">.</span>new(AES_KEY, AES<span style="color:#f92672">.</span>MODE_CBC, iv)
        ct <span style="color:#f92672">=</span> cipher<span style="color:#f92672">.</span>encrypt(pad(flag, AES<span style="color:#f92672">.</span>block_size))
        <span style="color:#66d9ef">return</span> (iv <span style="color:#f92672">+</span> ct)<span style="color:#f92672">.</span>hex()

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">handle_signing</span>() <span style="color:#f92672">-&gt;</span> tuple:
    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
        <span style="color:#66d9ef">try</span>:
            inp <span style="color:#f92672">=</span> input(<span style="color:#e6db74">&#34;Enter message to sign. (`!exit`) to return to the main menu.</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&gt;&gt; &#34;</span>)
            <span style="color:#66d9ef">if</span> inp <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;!exit&#34;</span>:
                <span style="color:#66d9ef">break</span>
            r,s <span style="color:#f92672">=</span> ecdsa_sign(KEY, inp)
            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Signature (r,s): </span><span style="color:#e6db74">{</span>(r, s)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
            
        <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">Exception</span> <span style="color:#66d9ef">as</span> e:
            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Error during signing: </span><span style="color:#e6db74">{</span>e<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
            <span style="color:#66d9ef">continue</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_valid_format</span>(inp) <span style="color:#f92672">-&gt;</span> bool:
    pattern <span style="color:#f92672">=</span> <span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;^\([^,]+,\d+,\d+\)$&#34;</span>
    match <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>match(pattern, inp)
    <span style="color:#66d9ef">return</span> bool(match)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">handle_verfication</span>():
    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
        inp <span style="color:#f92672">=</span> input(<span style="color:#e6db74">&#34;Enter the message you want to verify in the format `message,r,s` (`!exit` to return to the main menu).</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&gt;&gt; &#34;</span>)
        <span style="color:#66d9ef">if</span> inp <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;!exit&#39;</span>:
            <span style="color:#66d9ef">break</span>
        valid <span style="color:#f92672">=</span> is_valid_format(inp)
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> valid:
            print(<span style="color:#e6db74">&#34;Invalid input format. Please try again.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
            <span style="color:#66d9ef">continue</span>
        message, r, s <span style="color:#f92672">=</span> inp<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;,&#39;</span>)
        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;message: </span><span style="color:#e6db74">{</span>message<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">r: </span><span style="color:#e6db74">{</span>r<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">s: </span><span style="color:#e6db74">{</span>s<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
        <span style="color:#66d9ef">try</span>:
            i_r, i_s <span style="color:#f92672">=</span> int(r), int(s)
            valid <span style="color:#f92672">=</span> ecdsa_verify(Q, message, i_r, i_s)
            result <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Signature is valid</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#66d9ef">if</span> valid <span style="color:#66d9ef">else</span> <span style="color:#e6db74">&#34;Signature is invalid</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
            print(result)
        <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">Exception</span> <span style="color:#66d9ef">as</span> e:
            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Error during verification: </span><span style="color:#e6db74">{</span>e<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
            <span style="color:#66d9ef">continue</span>
        


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">process_option</span>(option: str) <span style="color:#f92672">-&gt;</span> str:
    <span style="color:#66d9ef">global</span> INVALID_ATTEMPTS
    <span style="color:#66d9ef">if</span> option <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;!1&#39;</span>:
        INVALID_ATTEMPTS <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        public_key_info <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Public Key (X, Y): </span><span style="color:#e6db74">{</span>Q<span style="color:#f92672">.</span>xy()<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
        print(public_key_info)
    <span style="color:#66d9ef">elif</span> option <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;!2&#39;</span>:
        INVALID_ATTEMPTS <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        handle_signing()
    <span style="color:#66d9ef">elif</span> option <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;!3&#39;</span>:
        INVALID_ATTEMPTS <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        handle_verfication()
    <span style="color:#66d9ef">elif</span> option <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;!4&#39;</span>:
        INVALID_ATTEMPTS <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        enc_flag <span style="color:#f92672">=</span> send_flag()
        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Encrypted Flag: </span><span style="color:#e6db74">{</span>enc_flag<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
    <span style="color:#66d9ef">elif</span> option <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;!5&#39;</span>:
        print(<span style="color:#e6db74">&#34;Goodbye!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
    <span style="color:#66d9ef">else</span>:
        INVALID_ATTEMPTS <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        print(<span style="color:#e6db74">&#34;Invalid option... Try again</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
        <span style="color:#66d9ef">if</span> INVALID_ATTEMPTS <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">3</span>:
            print(<span style="color:#e6db74">&#34;Too many invalid attempts. Exiting.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
        



<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
    <span style="color:#66d9ef">try</span>:
        b <span style="color:#f92672">=</span> banner()
        print(b<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
        <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
            
            inp <span style="color:#f92672">=</span> input(<span style="color:#e6db74">&#34;&gt;&gt; &#34;</span>)
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> process_option(inp):
                sys<span style="color:#f92672">.</span>exit(<span style="color:#ae81ff">0</span>)
    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">Exception</span> <span style="color:#66d9ef">as</span> e:
        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;An error occurred: </span><span style="color:#e6db74">{</span>e<span style="color:#e6db74">}</span><span style="color:#e6db74">, please try again later.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
        <span style="color:#66d9ef">pass</span>
    
    <span style="color:#66d9ef">finally</span>:
        sys<span style="color:#f92672">.</span>exit(<span style="color:#ae81ff">0</span>)

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    main()
</code></pre></div><hr>
<p><strong>Solution Source Code</strong></p>
<ul>
<li><code>exploit.py</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#f92672">from</span> sage.all <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#f92672">import</span> hashlib
<span style="color:#f92672">from</span> utils <span style="color:#f92672">import</span> PartialInteger, attack, dsa_known_msb, check_public_key, curve
<span style="color:#f92672">from</span> Crypto.Cipher <span style="color:#f92672">import</span> AES
<span style="color:#f92672">from</span> Crypto.Util.Padding <span style="color:#f92672">import</span> pad, unpad
<span style="color:#f92672">import</span> hashlib<span style="color:#f92672">,</span> re
<span style="color:#f92672">from</span> Crypto.Util.number <span style="color:#f92672">import</span> long_to_bytes, bytes_to_long
<span style="color:#f92672">import</span> sys
p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span>
K <span style="color:#f92672">=</span> GF(p)
a <span style="color:#f92672">=</span> K(<span style="color:#ae81ff">0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc</span>)
b <span style="color:#f92672">=</span> K(<span style="color:#ae81ff">0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00</span>)
E <span style="color:#f92672">=</span> EllipticCurve(K, (a, b))
G <span style="color:#f92672">=</span> E(<span style="color:#ae81ff">0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66</span>, <span style="color:#ae81ff">0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650</span>)
E<span style="color:#f92672">.</span>set_order(<span style="color:#ae81ff">0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x1</span>)
n <span style="color:#f92672">=</span> G<span style="color:#f92672">.</span>order()
DEFAULT_HOST,DEFAULT_PORT <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;172.17.0.2&#39;</span>, <span style="color:#ae81ff">1337</span>
host <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> len(sys<span style="color:#f92672">.</span>argv) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">else</span> DEFAULT_HOST
port <span style="color:#f92672">=</span> int(sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">2</span>]) <span style="color:#66d9ef">if</span> len(sys<span style="color:#f92672">.</span>argv) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">else</span> DEFAULT_PORT
n_sigs <span style="color:#f92672">=</span> int(sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">3</span>]) <span style="color:#66d9ef">if</span> len(sys<span style="color:#f92672">.</span>argv) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">100</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hasher</span>(m):
    hashed <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>from_bytes(hashlib<span style="color:#f92672">.</span>sha256(m<span style="color:#f92672">.</span>encode())<span style="color:#f92672">.</span>digest(), byteorder<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;big&#39;</span>)
    <span style="color:#66d9ef">return</span> hashed

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">parse_sig</span>(input_string):
    pattern <span style="color:#f92672">=</span> <span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;Signature \(r,\s*s\):\s*\((\d+),\s*(\d+)\)&#34;</span>
    match <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>search(pattern, input_string)
    <span style="color:#66d9ef">if</span> match:
        r <span style="color:#f92672">=</span> int(match<span style="color:#f92672">.</span>group(<span style="color:#ae81ff">1</span>))
        s <span style="color:#f92672">=</span> int(match<span style="color:#f92672">.</span>group(<span style="color:#ae81ff">2</span>))
        <span style="color:#66d9ef">return</span> (r, s)
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">parse_pub</span>(s):
    x <span style="color:#f92672">=</span> int(re<span style="color:#f92672">.</span>findall(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;Public Key \(X, Y\): \((\d+),&#34;</span>, s)[<span style="color:#ae81ff">0</span>])
    y <span style="color:#f92672">=</span> int(re<span style="color:#f92672">.</span>findall(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;Public Key \(X, Y\): \(\d+, (\d+)\)&#34;</span>, s)[<span style="color:#ae81ff">0</span>])
    <span style="color:#66d9ef">return</span> (x, y)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_pub</span>(r):
    r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&gt;&gt; &#34;</span>)
    r<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;!1&#34;</span>)
    pub <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>recvline()<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>decode()
    xy_pub <span style="color:#f92672">=</span> parse_pub(pub)
    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[+] Public Key Received: </span><span style="color:#e6db74">{</span>xy_pub<span style="color:#e6db74">}</span><span style="color:#e6db74"> [+]&#34;</span>)
    <span style="color:#66d9ef">return</span> xy_pub, pub

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_sigs</span>(n, r):
    sigs <span style="color:#f92672">=</span> []
    r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&gt;&gt; &#34;</span>)
    r<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;!2&#39;</span>)
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
        r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&gt;&gt; &#34;</span>)
        r<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;message&#34;</span>)
        sig_line <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>recvline()<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>decode()
        parsed_sig <span style="color:#f92672">=</span> parse_sig(sig_line)
        <span style="color:#66d9ef">if</span> parsed_sig:
            sigs<span style="color:#f92672">.</span>append(parsed_sig)
        <span style="color:#66d9ef">else</span>:
            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[-] Failed to parse signature: </span><span style="color:#e6db74">{</span>sig_line<span style="color:#e6db74">}</span><span style="color:#e6db74"> [-]&#34;</span>)
    r<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;!exit&#34;</span>)
    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[+] Total Parsed Signatures: </span><span style="color:#e6db74">{</span>len(sigs)<span style="color:#e6db74">}</span><span style="color:#e6db74"> [+]&#34;</span>)
    <span style="color:#66d9ef">return</span> sigs

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_flag</span>(r):
    r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&gt;&gt; &#34;</span>)
    
    r<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;!4&#34;</span>)
    dat <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>decode()
    stripped <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>findall(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;Encrypted Flag: ([a-f0-9]+)&#34;</span>, dat)
    print(dat)
    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[+] Received Encrypted Flag: </span><span style="color:#e6db74">{</span>stripped<span style="color:#e6db74">}</span><span style="color:#e6db74"> [+]&#34;</span>)
    <span style="color:#66d9ef">if</span> len(stripped) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
        r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&gt;&gt; &#34;</span>)
        r<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;!4&#34;</span>)
        dat2 <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>recvline()<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>decode()
        print(dat2)
        stripped <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>findall(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;Encrypted Flag: ([a-f0-9]+)&#34;</span>, dat2)[<span style="color:#ae81ff">0</span>]
        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[+] Received Encrypted Flag: </span><span style="color:#e6db74">{</span>stripped<span style="color:#e6db74">}</span><span style="color:#e6db74"> [+]&#34;</span>)
    <span style="color:#66d9ef">return</span> stripped

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decrypt_flag</span>(ciphertext, key):
    ciphertext <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(ciphertext)
    iv <span style="color:#f92672">=</span> ciphertext[:<span style="color:#ae81ff">16</span>]
    ciphertext <span style="color:#f92672">=</span> ciphertext[<span style="color:#ae81ff">16</span>:]
    cipher <span style="color:#f92672">=</span> AES<span style="color:#f92672">.</span>new(key, AES<span style="color:#f92672">.</span>MODE_CBC, iv)
    <span style="color:#66d9ef">return</span> unpad(cipher<span style="color:#f92672">.</span>decrypt(ciphertext), AES<span style="color:#f92672">.</span>block_size)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>(n_sigs:int):
    r <span style="color:#f92672">=</span> remote(host, port)
    print(<span style="color:#e6db74">&#34;[+] Connection established with the server. [+]&#34;</span>)
    <span style="color:#66d9ef">try</span>:
        <span style="color:#75715e"># list of k&#39;s</span>
        k_i <span style="color:#f92672">=</span> []
        <span style="color:#75715e"># list of hashed messages</span>
        h_i <span style="color:#f92672">=</span> []
        <span style="color:#75715e"># list of r&#39;s from ecdsa signatures</span>
        r_i <span style="color:#f92672">=</span> []
        <span style="color:#75715e"># list of s&#39; from ecdsa signatures</span>
        s_i <span style="color:#f92672">=</span> []
        msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;message&#34;</span>
        hashed <span style="color:#f92672">=</span> hasher(msg)
        <span style="color:#75715e"># get public key</span>
        pub, _ <span style="color:#f92672">=</span> get_pub(r)
        <span style="color:#75715e"># get n signatures</span>
        sigs <span style="color:#f92672">=</span> get_sigs(n_sigs, r)
        <span style="color:#75715e"># get the encrypted flag</span>
        flag <span style="color:#f92672">=</span> get_flag(r)
        <span style="color:#75715e"># partial integer for biased k&#39;s</span>
        ks <span style="color:#f92672">=</span> PartialInteger<span style="color:#f92672">.</span>from_bits_be(<span style="color:#e6db74">&#34;000000000&#34;</span><span style="color:#f92672">+</span>(<span style="color:#e6db74">&#34;?&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">512</span>))
        <span style="color:#66d9ef">for</span> r_s, s <span style="color:#f92672">in</span> sigs:
            r_s_i <span style="color:#f92672">=</span> str(r_s)<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#34;,&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>)
            s_i<span style="color:#f92672">.</span>append(int(s))
            r_i<span style="color:#f92672">.</span>append(int(r_s_i))
            k_i<span style="color:#f92672">.</span>append(ks)
            h_i<span style="color:#f92672">.</span>append(hashed)
        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[+] Arrays lengths</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">-&gt; h_i: </span><span style="color:#e6db74">{</span>len(h_i)<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">-&gt; r_i: </span><span style="color:#e6db74">{</span>len(r_i)<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">-&gt; s_i: </span><span style="color:#e6db74">{</span>len(s_i)<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">-&gt; k_i: </span><span style="color:#e6db74">{</span>len(k_i)<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">[+]&#34;</span>)
        
        <span style="color:#66d9ef">for</span> d_, _ <span style="color:#f92672">in</span> dsa_known_msb(n, h_i, r_i, s_i, k_i):
            <span style="color:#66d9ef">if</span> check_public_key(int(d_), curve, pub[<span style="color:#ae81ff">0</span>], pub[<span style="color:#ae81ff">1</span>]):
                print(<span style="color:#e6db74">&#34;[+] Success: Correct private key found. [+]&#34;</span>)
                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[+] Private Key: </span><span style="color:#e6db74">{</span>d_<span style="color:#e6db74">}</span><span style="color:#e6db74"> [+]&#34;</span>)
                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[+] AES_KEY: </span><span style="color:#e6db74">{</span>hashlib<span style="color:#f92672">.</span>sha256(long_to_bytes(int(d_)))<span style="color:#f92672">.</span>hexdigest()<span style="color:#e6db74">}</span><span style="color:#e6db74"> [+]&#34;</span>)
                dec_flag <span style="color:#f92672">=</span> decrypt_flag(flag, hashlib<span style="color:#f92672">.</span>sha256(long_to_bytes(int(d_)))<span style="color:#f92672">.</span>digest())
                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[+] Decrypted Flag: </span><span style="color:#e6db74">{</span>dec_flag<span style="color:#f92672">.</span>decode()<span style="color:#e6db74">}</span><span style="color:#e6db74"> [+]&#34;</span>)
                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;/[+]</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">After </span><span style="color:#e6db74">{</span>n_sigs<span style="color:#e6db74">}</span><span style="color:#e6db74"> signatures, private key has been successfully recovered and the flag decrypted /[+]</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#34;</span>)
                <span style="color:#66d9ef">break</span>
            <span style="color:#66d9ef">else</span>:
                print(<span style="color:#e6db74">&#34;Unsuccessful attack on attempt #&#34;</span>)
    <span style="color:#66d9ef">finally</span>:
        r<span style="color:#f92672">.</span>close()
        print(<span style="color:#e6db74">&#34;Connection closed.&#34;</span>)

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
    main(n_sigs)
</code></pre></div><ul>
<li><code>utils.py</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> cryptography.hazmat.primitives.asymmetric <span style="color:#f92672">import</span> ec
<span style="color:#f92672">from</span> cryptography.hazmat.primitives <span style="color:#f92672">import</span> serialization
<span style="color:#f92672">from</span> cryptography.hazmat.backends <span style="color:#f92672">import</span> default_backend
<span style="color:#f92672">from</span> sage.all <span style="color:#f92672">import</span> matrix, QQ
<span style="color:#f92672">import</span> hashlib
<span style="color:#f92672">import</span> re
<span style="color:#f92672">from</span> math <span style="color:#f92672">import</span> log2
curve <span style="color:#f92672">=</span> ec<span style="color:#f92672">.</span>SECP521R1()

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">parse_pub</span>(inp):
    <span style="color:#66d9ef">try</span>:
        match <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>search(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;Public Key \(X, Y\): \((\d+), (\d+)\)&#34;</span>, inp)
        <span style="color:#66d9ef">if</span> match:
            x <span style="color:#f92672">=</span> int(match<span style="color:#f92672">.</span>group(<span style="color:#ae81ff">1</span>))
            y <span style="color:#f92672">=</span> int(match<span style="color:#f92672">.</span>group(<span style="color:#ae81ff">2</span>))
            <span style="color:#66d9ef">return</span> x, y
    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">Exception</span> <span style="color:#66d9ef">as</span> e:
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">parse_sig</span>(data):
    match <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>search(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;Signature \(r, s\): \((\d+), (\d+)\)&#39;</span>, data)
    <span style="color:#75715e">#print(data)</span>
    <span style="color:#75715e">#print(match)</span>
    <span style="color:#66d9ef">if</span> match:
        <span style="color:#66d9ef">return</span> int(match<span style="color:#f92672">.</span>group(<span style="color:#ae81ff">1</span>)), int(match<span style="color:#f92672">.</span>group(<span style="color:#ae81ff">2</span>))
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>



<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hashmsg</span>(m):
    <span style="color:#e6db74">&#34;&#34;&#34; Hash a message using SHA-256 and return the integer representation. &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">if</span> isinstance(m, str):
        m <span style="color:#f92672">=</span> m<span style="color:#f92672">.</span>encode()
    <span style="color:#66d9ef">return</span> int<span style="color:#f92672">.</span>from_bytes(hashlib<span style="color:#f92672">.</span>sha256(m)<span style="color:#f92672">.</span>digest(), byteorder<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;big&#39;</span>)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">check_public_key</span>(private_int, curve, known_x, known_y):
    private_key <span style="color:#f92672">=</span> ec<span style="color:#f92672">.</span>derive_private_key(private_int, curve, default_backend())
    public_key <span style="color:#f92672">=</span> private_key<span style="color:#f92672">.</span>public_key()
    public_numbers <span style="color:#f92672">=</span> public_key<span style="color:#f92672">.</span>public_numbers()
    <span style="color:#66d9ef">return</span> (public_numbers<span style="color:#f92672">.</span>x <span style="color:#f92672">==</span> known_x) <span style="color:#f92672">and</span> (public_numbers<span style="color:#f92672">.</span>y <span style="color:#f92672">==</span> known_y)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">int_to_openssh</span>(private_int, curve):
    private_key <span style="color:#f92672">=</span> ec<span style="color:#f92672">.</span>derive_private_key(private_int, curve, default_backend())
    pem <span style="color:#f92672">=</span> private_key<span style="color:#f92672">.</span>private_bytes(
        encoding<span style="color:#f92672">=</span>serialization<span style="color:#f92672">.</span>Encoding<span style="color:#f92672">.</span>PEM,
        format<span style="color:#f92672">=</span>serialization<span style="color:#f92672">.</span>PrivateFormat<span style="color:#f92672">.</span>OpenSSH,
        encryption_algorithm<span style="color:#f92672">=</span>serialization<span style="color:#f92672">.</span>NoEncryption()
    )
    <span style="color:#66d9ef">return</span> pem<span style="color:#f92672">.</span>decode()
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">shortest_vectors</span>(B):
    B <span style="color:#f92672">=</span> B<span style="color:#f92672">.</span>LLL()

    <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> B<span style="color:#f92672">.</span>rows():
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> row<span style="color:#f92672">.</span>is_zero():
            <span style="color:#66d9ef">yield</span> row


<span style="color:#75715e"># Source: https://github.com/jvdsn/crypto-attacks/blob/master/attacks/hnp/lattice_attack.py</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">attack</span>(a, b, m, X):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Solves the hidden number problem using an attack based on the shortest vector problem.
</span><span style="color:#e6db74">    The hidden number problem is defined as finding y such that {xi = {aij * yj} + bi mod m}.
</span><span style="color:#e6db74">    :param a: the aij values
</span><span style="color:#e6db74">    :param b: the bi values
</span><span style="color:#e6db74">    :param m: the modulus
</span><span style="color:#e6db74">    :param X: a bound on the xi values
</span><span style="color:#e6db74">    :return: a generator generating tuples containing a list of xi values and a list of yj values
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">assert</span> len(a) <span style="color:#f92672">==</span> len(b), <span style="color:#e6db74">&#34;a and b lists should be of equal length.&#34;</span>

    n1 <span style="color:#f92672">=</span> len(a)
    n2 <span style="color:#f92672">=</span> len(a[<span style="color:#ae81ff">0</span>])
    B <span style="color:#f92672">=</span> matrix(QQ, n1 <span style="color:#f92672">+</span> n2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, n1 <span style="color:#f92672">+</span> n2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n1):
        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n2):
            B[n1 <span style="color:#f92672">+</span> j, i] <span style="color:#f92672">=</span> a[i][j]

        B[i, i] <span style="color:#f92672">=</span> m
        B[n1 <span style="color:#f92672">+</span> n2, i] <span style="color:#f92672">=</span> b[i] <span style="color:#f92672">-</span> X <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>

    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n2):
        B[n1 <span style="color:#f92672">+</span> j, n1 <span style="color:#f92672">+</span> j] <span style="color:#f92672">=</span> X <span style="color:#f92672">/</span> QQ(m)

    B[n1 <span style="color:#f92672">+</span> n2, n1 <span style="color:#f92672">+</span> n2] <span style="color:#f92672">=</span> X

    <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> shortest_vectors(B):
        xs <span style="color:#f92672">=</span> [int(v[i] <span style="color:#f92672">+</span> X <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n1)]
        ys <span style="color:#f92672">=</span> [(int(v[n1 <span style="color:#f92672">+</span> j] <span style="color:#f92672">*</span> m) <span style="color:#f92672">//</span> X) <span style="color:#f92672">%</span> m <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n2)]
        <span style="color:#66d9ef">if</span> all(y <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> ys) <span style="color:#f92672">and</span> v[n1 <span style="color:#f92672">+</span> n2] <span style="color:#f92672">==</span> X:
            <span style="color:#66d9ef">yield</span> xs, ys
<span style="color:#75715e"># Source: https://github.com/jvdsn/crypto-attacks/blob/master/attacks/hnp/lattice_attack.py</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dsa_known_msb</span>(n, h, r, s, k):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Recovers the (EC)DSA private key and nonces if the most significant nonce bits are known.
</span><span style="color:#e6db74">    :param n: the modulus
</span><span style="color:#e6db74">    :param h: a list containing the hashed messages
</span><span style="color:#e6db74">    :param r: a list containing the r values
</span><span style="color:#e6db74">    :param s: a list containing the s values
</span><span style="color:#e6db74">    :param k: a list containing the partial nonces (PartialIntegers)
</span><span style="color:#e6db74">    :return: a generator generating tuples containing the possible private key and a list of nonces
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">assert</span> len(h) <span style="color:#f92672">==</span> len(r) <span style="color:#f92672">==</span> len(s) <span style="color:#f92672">==</span> len(k), <span style="color:#e6db74">&#34;h, r, s, and k lists should be of equal length.&#34;</span>
    a <span style="color:#f92672">=</span> []
    b <span style="color:#f92672">=</span> []
    X <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> hi, ri, si, ki <span style="color:#f92672">in</span> zip(h, r, s, k):
        msb, msb_bit_length <span style="color:#f92672">=</span> ki<span style="color:#f92672">.</span>get_known_msb()
        shift <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> ki<span style="color:#f92672">.</span>get_unknown_lsb()
        a<span style="color:#f92672">.</span>append([(pow(si, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, n) <span style="color:#f92672">*</span> ri) <span style="color:#f92672">%</span> n])
        b<span style="color:#f92672">.</span>append((pow(si, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, n) <span style="color:#f92672">*</span> hi <span style="color:#f92672">-</span> shift <span style="color:#f92672">*</span> msb) <span style="color:#f92672">%</span> n)
        X <span style="color:#f92672">=</span> max(X, shift)

    <span style="color:#66d9ef">for</span> k_, x <span style="color:#f92672">in</span> attack(a, b, n, X):
        <span style="color:#66d9ef">yield</span> x[<span style="color:#ae81ff">0</span>], [ki<span style="color:#f92672">.</span>sub([ki_]) <span style="color:#66d9ef">for</span> ki, ki_ <span style="color:#f92672">in</span> zip(k, k_)]

<span style="color:#75715e"># Source: https://github.com/jvdsn/crypto-attacks/blob/master/shared/partial_integer.py</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PartialInteger</span>:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Represents positive integers with some known and some unknown bits.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>

    <span style="color:#66d9ef">def</span> __init__(self):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Constructs a new PartialInteger with total bit length 0 and no components.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        self<span style="color:#f92672">.</span>bit_length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        self<span style="color:#f92672">.</span>unknowns <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        self<span style="color:#f92672">.</span>_components <span style="color:#f92672">=</span> []

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add_known</span>(self, value, bit_length):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Adds a known component to the msb of this PartialInteger.
</span><span style="color:#e6db74">        :param value: the value of the component
</span><span style="color:#e6db74">        :param bit_length: the bit length of the component
</span><span style="color:#e6db74">        :return: this PartialInteger, with the component added to the msb
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        self<span style="color:#f92672">.</span>bit_length <span style="color:#f92672">+=</span> bit_length
        self<span style="color:#f92672">.</span>_components<span style="color:#f92672">.</span>append((value, bit_length))
        <span style="color:#66d9ef">return</span> self

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add_unknown</span>(self, bit_length):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Adds an unknown component to the msb of this PartialInteger.
</span><span style="color:#e6db74">        :param bit_length: the bit length of the component
</span><span style="color:#e6db74">        :return: this PartialInteger, with the component added to the msb
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        self<span style="color:#f92672">.</span>bit_length <span style="color:#f92672">+=</span> bit_length
        self<span style="color:#f92672">.</span>unknowns <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        self<span style="color:#f92672">.</span>_components<span style="color:#f92672">.</span>append((<span style="color:#66d9ef">None</span>, bit_length))
        <span style="color:#66d9ef">return</span> self
    <span style="color:#f92672">.</span>
    ,
<span style="color:#f92672">...</span>
[SNIP]
<span style="color:#f92672">...</span>
</code></pre></div><h3 id="challenge-overview">Challenge Overview</h3>
<ol>
<li><strong>Public Key Retrieval</strong>: The challenge provides an option to retrieve the public key.</li>
<li><strong>Signature Generation</strong>: The user can generate multiple ECDSA signatures.</li>
<li><strong>Signature Verification</strong>: The user can verify the validity of given signatures.</li>
<li><strong>Encrypted Flag Retrieval</strong>: The challenge provides an option to retrieve an encrypted flag.</li>
</ol>
<p>The goal is to recover the private key used for signing messages by leveraging biased nonces in the ECDSA signature process. Once the private key is obtained, it can be used to derive the AES key, which is then used to decrypt the flag.</p>
<h3 id="technical-details">Technical Details</h3>
<h4 id="ecdsa-signature-scheme">ECDSA Signature Scheme</h4>
<p>In ECDSA, a signature for a message $m$ is generated as follows:</p>
<ol>
<li>Compute the hash of the message, $e = \text{HASH}(m)$.</li>
<li>Generate a random nonce $k$.</li>
<li>Compute the elliptic curve point $P = kG$, where $G$ is the base point of the curve.</li>
<li>The signature components are:
<ul>
<li>$r = x_P \mod n$, where $x_P$ is the x-coordinate of $P$</li>
<li>$s = k^{-1}(e + rd) \mod n$, where $d$ is the private key.</li>
</ul>
</li>
<li>The signature is $(r, s)$.</li>
</ol>
<p>The public key $Q$ is computed as $Q = dG$.</p>
<h4 id="challenge-implementation">Challenge Implementation</h4>
<p>The provided <code>challenge.py</code> script performs the ECDSA signing and encryption of the flag. The <code>ecdsa_sign</code> function generates signatures using a biased nonce $k$ where the $9$ most significant bits (MSBs) are zero. This is a common mistake with the NIST P-521 Curve as it can be easily mistaken for $512$ instead of $521$.</p>
<p><strong>Vulnerability</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_k</span>() <span style="color:#f92672">-&gt;</span> int:
    <span style="color:#66d9ef">return</span> int<span style="color:#f92672">.</span>from_bytes(hashlib<span style="color:#f92672">.</span>sha512(os<span style="color:#f92672">.</span>urandom(<span style="color:#ae81ff">512</span><span style="color:#f92672">//</span><span style="color:#ae81ff">8</span>))<span style="color:#f92672">.</span>digest(), byteorder<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;big&#39;</span>) <span style="color:#f92672">%</span> n

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ecdsa_sign</span>(d: int, m: str) <span style="color:#f92672">-&gt;</span> Tuple[int, int]:
    e <span style="color:#f92672">=</span> digest(m)
    k <span style="color:#f92672">=</span> get_k()
    P <span style="color:#f92672">=</span> k <span style="color:#f92672">*</span> G
    r_i <span style="color:#f92672">=</span> int(P<span style="color:#f92672">.</span>xy()[<span style="color:#ae81ff">0</span>])
    s_i <span style="color:#f92672">=</span> (pow(k, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, n) <span style="color:#f92672">*</span> (e <span style="color:#f92672">+</span> r_i <span style="color:#f92672">*</span> d)) <span style="color:#f92672">%</span> n
    <span style="color:#66d9ef">return</span> (r_i, s_i)
</code></pre></div><h4 id="lattice-attack">Lattice Attack</h4>
<p>The lattice attack leverages the structure of the signature equations to recover the private key. Given several signatures $(r_i, s_i)$ for messages $m_i$:</p>
<ol>
<li>Compute the hash of each message $e_i = \text{HASH}(m_i)$.</li>
<li>For each signature, express $s_i$ as:
$$s_i = k_i^{-1}(e_i + r_i d) \mod n$$
Rearrange to get:
$$k_i = s_i^{-1}(e_i + r_i d) \mod n$$</li>
<li>Using the biased $k$ values, we know the MSBs are zero. This can be modeled as a hidden number problem (HNP).</li>
<li>Construct a lattice basis to solve for the private key $d$ using the Lenstra–Lenstra–Lovász (LLL) algorithm.</li>
</ol>
<h4 id="solution-script">Solution Script</h4>
<p>The <code>exploit.py</code> script performs the following steps to recover the private key and decrypt the flag:</p>
<ol>
<li>
<p><strong>Retrieve Public Key</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">pub, _ <span style="color:#f92672">=</span> get_pub(r)
</code></pre></div></li>
<li>
<p><strong>Retrieve Signatures</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">sigs <span style="color:#f92672">=</span> get_sigs(n_sigs, r)
</code></pre></div></li>
<li>
<p><strong>Retrieve Encrypted Flag</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">flag <span style="color:#f92672">=</span> get_flag(r)
</code></pre></div></li>
<li>
<p><strong>Construct Partial Integers for Biased k Values</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">ks <span style="color:#f92672">=</span> PartialInteger<span style="color:#f92672">.</span>from_bits_be(<span style="color:#e6db74">&#34;000000000&#34;</span> <span style="color:#f92672">+</span> (<span style="color:#e6db74">&#34;?&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">512</span>))
</code></pre></div></li>
<li>
<p><strong>Set Up Arrays for Lattice Attack</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">for</span> r_s, s <span style="color:#f92672">in</span> sigs:
    r_s_i <span style="color:#f92672">=</span> str(r_s)<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#34;,&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>)
    s_i<span style="color:#f92672">.</span>append(int(s))
    r_i<span style="color:#f92672">.</span>append(int(r_s_i))
    k_i<span style="color:#f92672">.</span>append(ks)
    h_i<span style="color:#f92672">.</span>append(hashed)
</code></pre></div></li>
<li>
<p><strong>Perform Lattice Attack</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">for</span> d_, _ <span style="color:#f92672">in</span> dsa_known_msb(n, h_i, r_i, s_i, k_i):
    <span style="color:#66d9ef">if</span> check_public_key(int(d_), curve, pub[<span style="color:#ae81ff">0</span>], pub[<span style="color:#ae81ff">1</span>]):
        <span style="color:#75715e"># Private key found</span>
        <span style="color:#66d9ef">break</span>
</code></pre></div></li>
<li>
<p><strong>Decrypt Flag</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">dec_flag <span style="color:#f92672">=</span> decrypt_flag(flag, hashlib<span style="color:#f92672">.</span>sha256(long_to_bytes(int(d_)))<span style="color:#f92672">.</span>digest())
</code></pre></div></li>
</ol>
<h4 id="explanation-of-lattice-construction">Explanation of Lattice Construction</h4>
<p>The lattice attack constructs a basis matrix $B$ such that the shortest vector corresponds to the correct solution of the HNP:</p>
<ol>
<li>Construct a matrix $B$ of dimension $n1 + n2 + 1 \times n1 + n2 + 1$.</li>
<li>Populate the matrix with known values from the signature equations.</li>
<li>Apply the LLL algorithm to find the shortest vector.</li>
<li>Extract potential solutions for the private key and verify.</li>
</ol>
<h4 id="conclusion">Conclusion</h4>
<p>This challenge demonstrates the practical application of lattice-based cryptanalysis to break ECDSA when nonces are biased. By carefully analyzing the signatures and constructing a suitable lattice, the private key can be recovered, allowing for the decryption of the flag. This attack underscores the importance of using strong, unbiased random values in cryptographic protocols.</p>
<h5 id="script-in-use">Script in use</h5>
<p><a href="https://github.com/supaaasuge/CTF-Challenges/blob/main/crypto-on-the-rocks/solution/exploit.py">exploit.py</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">python exploit.py 
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Opening connection to 172.17.0.2 on port 1337: Done
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Connection established with the server. <span style="color:#f92672">[</span>+<span style="color:#f92672">]</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Public Key Received: <span style="color:#f92672">(</span>3109980590986919311287046533887492002477811552891909791863089310727982955200855447689228284912554348477907370491007162534350370090834859510917441206285191833, 1849341532655318689606938160662082719013085154529414983552465624971698466645605396348569232219887646346509053390109036465552085426099099404907799665353982020<span style="color:#f92672">)</span> <span style="color:#f92672">[</span>+<span style="color:#f92672">]</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Total Parsed Signatures: <span style="color:#ae81ff">100</span> <span style="color:#f92672">[</span>+<span style="color:#f92672">]</span>
██████████╗░░█████╗░░█████╗░███████╗█
<span style="color:#f92672">[=]</span> ------------ Menu------------ <span style="color:#f92672">[=]</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> !1: Get Public Key            <span style="color:#f92672">[</span>+<span style="color:#f92672">]</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> !2: Sign a message            <span style="color:#f92672">[</span>+<span style="color:#f92672">]</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> !3: Verify a signature        <span style="color:#f92672">[</span>+<span style="color:#f92672">]</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> !4: Get the encrypted flag    <span style="color:#f92672">[</span>+<span style="color:#f92672">]</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> !5: Exit                      <span style="color:#f92672">[</span>+<span style="color:#f92672">]</span>
<span style="color:#f92672">[=]</span> ------------------------------<span style="color:#f92672">[=]</span>
██████████╗░░█████╗░░█████╗░███████╗█


&gt;&gt;
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Received Encrypted Flag: <span style="color:#f92672">[]</span> <span style="color:#f92672">[</span>+<span style="color:#f92672">]</span>
Encrypted Flag: 4bce8bc72f8ed73016a7fa8b3c0543e863dbb4ac382707d3f916b49450faa64c3324aed5f5052917901c35ba1b1a03f01b60a098b8965511be9b461d2d447fc3
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Received Encrypted Flag: 4bce8bc72f8ed73016a7fa8b3c0543e863dbb4ac382707d3f916b49450faa64c3324aed5f5052917901c35ba1b1a03f01b60a098b8965511be9b461d2d447fc3 <span style="color:#f92672">[</span>+<span style="color:#f92672">]</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Arrays lengths
-&gt; h_i: <span style="color:#ae81ff">100</span>
-&gt; r_i: <span style="color:#ae81ff">100</span>
-&gt; s_i: <span style="color:#ae81ff">100</span>
-&gt; k_i: <span style="color:#ae81ff">100</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Success: Correct private key found. <span style="color:#f92672">[</span>+<span style="color:#f92672">]</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Private Key: <span style="color:#ae81ff">4382437925999591767510550313910999914971677081144417715676670125599319162854128772342173165773504391470287477162386441738612489510063693972385644281868216440</span> <span style="color:#f92672">[</span>+<span style="color:#f92672">]</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> AES_KEY: c10216d682898955ef6fbb64afeca03c9bb5a68b4bcaaa9ca792991371b2214c <span style="color:#f92672">[</span>+<span style="color:#f92672">]</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Decrypted Flag: L3AK<span style="color:#f92672">{</span>9_b1ts_12_m0r3_th4n_3n0ugh<span style="color:#f92672">}</span> <span style="color:#f92672">[</span>+<span style="color:#f92672">]</span>
</code></pre></div><h6 id="sources">Sources</h6>
<ul>
<li><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/wishlist/vuln-p521-bias.html">https://www.chiark.greenend.org.uk/~sgtatham/putty/wishlist/vuln-p521-bias.html</a></li>
<li><a href="https://www.cert.europa.eu/publications/security-advisories/2024-039/pdf">https://www.cert.europa.eu/publications/security-advisories/2024-039/pdf</a></li>
<li><a href="https://www.openwall.com/lists/oss-security/2024/04/15/6">https://www.openwall.com/lists/oss-security/2024/04/15/6</a></li>
<li><a href="https://github.com/jvdsn/crypto-attacks">https://github.com/jvdsn/crypto-attacks</a></li>
<li><a href="https://github.com/advisories/GHSA-6p4c-r453-8743">https://github.com/advisories/GHSA-6p4c-r453-8743</a></li>
</ul>
</div>
    </article>
  </main>

      </div>
      <footer>
  <hr />
  
    <p id="social">
      Find me around the web:
      <br />
      
        
        <a href="https://github.com/supaaasuge">GitHub</a>
      
         | 
        <a href="https://x.com/supaaasuge">Twitter</a>
      
    </p>
  
  <p class="copyright">
    Copyright © 2024
    <a href="https://supaaasuge.github.io/"><strong>Supaaasuge</strong></a>.
    This work is licensed under the
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license.
  </p>
  <p class="builtWith">
    Built with
    <a href="http://www.gohugo.io/">Hugo</a>,
    using the theme
    <a href="https://gitlab.com/ian-s-mcb/smigle-hugo-theme">smigle</a>,
    which was influenced by the theme
    <a href="https://github.com/sumnerevans/smol">smol</a>.
  </p>
</footer>

    </div>
  </body>
</html>
